# -*- coding: utf-8 -*-
"""multi-outputs model

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pEATcEZL6ckQx0Oy-bRtF7lgmm6CPmqL
"""

# Commented out IPython magic to ensure Python compatibility.
# Importing the Boston Housing dataset
from sklearn.datasets import load_boston
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from matplotlib import pyplot as plt

import pandas as pd
import numpy as np 

try:
  # %tensorflow_version only exists in Colab.
#   %tensorflow_version 2.x
except Exception:
  pass
import tensorflow as tf

print("Tensorflow version " + tf.__version__)

boston = load_boston()

df = pd.DataFrame(boston.data, columns = boston.feature_names)

#Adding target variable to dataframe
df['PRICE'] = boston.target

"""**Data Overview**"""

df.head()

# Split the data into train and test with 80 train / 20 test

train, test = train_test_split(df, test_size=0.2, random_state = 1)
train, dev = train_test_split(train, test_size=0.2, random_state = 1)

# scale the data
scaler = MinMaxScaler()

scalre_train = scaler.fit_transform(train)
scalre_dev = scaler.transform(dev)
scalre_test = scaler.transform(test)

scalre_train = pd.DataFrame(scalre_train, columns=train.columns)
scalre_dev = pd.DataFrame(scalre_dev, columns=train.columns)
scalre_test = pd.DataFrame(scalre_test, columns=train.columns)

y_train = scalre_train[['PRICE', 'PTRATIO']]
y_dev = scalre_dev[['PRICE', 'PTRATIO']]
y_test = scalre_test[['PRICE', 'PTRATIO']]

def dense_layers(inputs):
    """
    :param inputs:
    :return:
    """
    input_layer = tf.keras.layers.Input(shape=(inputs,))
    dense_layer = tf.keras.layers.Dense(units='512', activation='relu')(input_layer)
    first_dense = tf.keras.layers.Dense(units='128', activation='relu')(dense_layer)
    second_dense = tf.keras.layers.Dense(units='128',activation='relu')(first_dense)
    return input_layer, first_dense, second_dense


def price_regressor(first_dense):
    """
    :param first_dense:
    :return:
    """
    return tf.keras.layers.Dense(units=1, name='price_output')(first_dense)

def ratio_regressor(second_dense):
    """
    :param second_dense:
    :return:
    """
    return tf.keras.layers.Dense(units=1, name='ptratio_output')(second_dense)


def build_model(inputs):
    """
    :param inputs: 
    :return: 
    """"
    input_layer, first_dense, second_dense = dense_layers(inputs)
    y1_output = price_regressor(first_dense)
    y2_output = ratio_regressor(second_dense)
    return tf.keras.Model(inputs=input_layer,
                               outputs=[y1_output, y2_output])


def define_and_compile_model():
    """
    :return:
    """
    model = build_model(len(train.columns))
    model.compile(optimizer='adam',
              loss = {'price_output' : 'mse',
                      'ptratio_output' : 'mse'
                     },
              metrics = {'price_output' : 'mae',
                         'ptratio_output' : 'mae'
                        })
    return model


model = define_and_compile_model()
model.summary()

# Train the model for 100 epochs
history = model.fit(scalre_train, y_train,
   epochs=100, batch_size=10, validation_data=(scalre_dev, y_dev))

# Test the model and print loss and rmse for both outputs
loss,Y1_loss,Y2_loss,Y1_rmse,Y2_rmse=model.evaluate(x=scalre_test, y=y_test)
print()
print(f'loss: {loss}')
print(f'price_loss: {Y1_loss}')
print(f'ptratio_loss: {Y2_loss}')
print(f'price_rmse: {Y1_rmse}')
print(f'ptratio_rmse: {Y2_rmse}')

dict(history.history).keys()

plt.plot(pd.DataFrame(history.history['loss']))
plt.plot(pd.DataFrame(history.history['ptratio_output_loss']))
plt.plot(pd.DataFrame(history.history['price_output_loss']))
plt.legend(['loss', 'ptratio_output_loss', 'price_output_loss'])
plt.show()

plt.plot(pd.DataFrame(history.history['val_'+'loss']))
plt.plot(pd.DataFrame(history.history['val_'+'ptratio_output_loss']))
plt.plot(pd.DataFrame(history.history['val_'+'price_output_loss']))
plt.legend(['loss', 'ptratio_output_loss', 'price_output_loss'])
plt.show()

